{"version":3,"file":"avalanche-js-crypto.cjs.production.min.js","sources":["../src/random.ts","../src/errors.ts","../src/bytes.ts","../src/keccak256.ts","../src/bech32.ts","../src/rlp.ts","../src/keyTool.ts","../src/keystore.ts","../src/address.ts"],"sourcesContent":["/**\n * @packageDocumentation\n * @module avalanche-crypto\n */\n\n/**\n * Uses JS-native CSPRNG to generate a specified number of bytes.\n * @NOTE\n * this method throws if no PRNG is available.\n * @param {Number} bytes bytes number to generate\n * @return {String} ramdom hex string\n */\nexport const randomBytes = (bytes: number): string => {\n  let randBz: number[] | Uint8Array;\n\n  if (typeof window !== 'undefined' && window.crypto && window.crypto.getRandomValues) {\n    randBz = window.crypto.getRandomValues(new Uint8Array(bytes));\n  } else if (typeof require !== 'undefined') {\n    randBz = require('crypto').randomBytes(bytes);\n  } else {\n    throw new Error('Unable to generate safe random numbers.');\n  }\n\n  let randStr = '';\n  for (let i = 0; i < bytes; i += 1) {\n    randStr += `00${randBz[i].toString(16)}`.slice(-2);\n  }\n\n  return randStr;\n};\n","/**\n # avalanche-js-crypto\n\nThis package provides a collection of apis related to address management, kestore, encoding, and encrypt/decrypt.\n\n## Installation\n\n```\nnpm install avalanche-js-crypto\n```\n\n## Usage\n\n```javascript\n* const {\n*   encode,\n*   decode,\n*   randomBytes,\n*   toBech32,\n*   fromBech32,\n*   AvalancheAddress,\n*   generatePrivateKey,\n*   getPubkeyFromPrivateKey,\n*   getAddressFromPublicKey,\n*   getAddressFromPrivateKey,\n*   encryptPhrase,\n*   decryptPhrase\n* } = require('avalanche-js-crypto');\n* const { isPrivateKey, isAddress, isPublicKey } = require('avalanche-js-utils');\n```\n\nAddress apis\n```javascript\nconst bytes = randomBytes(20);\nconst addr = new AvalancheAddress(bytes);\n\nconsole.log(addr.checksum);\nconsole.log(addr.bech32);\n\nconsole.log(AvalancheAddress.isValidBech32(addr.bech32));\n```\n\nRLP apis\n```javascript\nconst encoded = '0x89010101010101010101';\nconst decoded = '0x010101010101010101';\nconsole.log(encode(decoded));\nconsole.log(decode(encoded));\n```\n\nKeystore apis\n```javascript\nconst prv = generatePrivateKey();\nconst pub = getPubkeyFromPrivateKey(prv);\nconst addr = getAddressFromPublicKey(pub);\nconst addrPrv = getAddressFromPrivateKey(prv);\nconsole.log(isPrivateKey(prv));\nconsole.log(isPublicKey(pub));\nconsole.log(isAddress(addr));\nconsole.log(isAddress(addrPrv));\n```\n\nEncrypt/decrypt apis\n```javascript\n* const { Wallet } = require('avalanche-js-account');\n\n* const myPhrase = new Wallet().newMnemonic();\n* console.log(myPhrase);\n* const pwd = '1234';\n* encryptPhrase(myPhrase, pwd).then((value) => {\n*   console.log(value);\n*   decryptPhrase(JSON.parse(value), pwd).then(value => {\n*     console.log(value);\n*   });\n* });\n```\n *\n * @packageDocumentation\n * @module avalanche-crypto\n */\n\n// This file is ported from ether.js/src.ts/errors.ts\n\n// Unknown Error\n/** @hidden */\nexport const UNKNOWN_ERROR = 'UNKNOWN_ERROR';\n\n// Not implemented\n/** @hidden */\nexport const NOT_IMPLEMENTED = 'NOT_IMPLEMENTED';\n\n// Missing new operator to an object\n//  - name: The name of the class\n/** @hidden */\nexport const MISSING_NEW = 'MISSING_NEW';\n\n// Call exception\n//  - transaction: the transaction\n//  - address?: the contract address\n//  - args?: The arguments passed into the function\n//  - method?: The Solidity method signature\n//  - errorSignature?: The EIP848 error signature\n//  - errorArgs?: The EIP848 error parameters\n//  - reason: The reason (only for EIP848 \"Error(string)\")\n/** @hidden */\nexport const CALL_EXCEPTION = 'CALL_EXCEPTION';\n\n// Invalid argument (e.g. value is incompatible with type) to a function:\n//   - argument: The argument name that was invalid\n//   - value: The value of the argument\n/** @hidden */\nexport const INVALID_ARGUMENT = 'INVALID_ARGUMENT';\n\n// Missing argument to a function:\n//   - count: The number of arguments received\n//   - expectedCount: The number of arguments expected\n/** @hidden */\nexport const MISSING_ARGUMENT = 'MISSING_ARGUMENT';\n\n// Too many arguments\n//   - count: The number of arguments received\n//   - expectedCount: The number of arguments expected\n/** @hidden */\nexport const UNEXPECTED_ARGUMENT = 'UNEXPECTED_ARGUMENT';\n\n// Numeric Fault\n//   - operation: the operation being executed\n//   - fault: the reason this faulted\n/** @hidden */\nexport const NUMERIC_FAULT = 'NUMERIC_FAULT';\n\n// Insufficien funds (< value + gasLimit * gasPrice)\n//   - transaction: the transaction attempted\n/** @hidden */\nexport const INSUFFICIENT_FUNDS = 'INSUFFICIENT_FUNDS';\n\n// Nonce has already been used\n//   - transaction: the transaction attempted\n/** @hidden */\nexport const NONCE_EXPIRED = 'NONCE_EXPIRED';\n\n// The replacement fee for the transaction is too low\n//   - transaction: the transaction attempted\n/** @hidden */\nexport const REPLACEMENT_UNDERPRICED = 'REPLACEMENT_UNDERPRICED';\n\n// Unsupported operation\n//   - operation\n/** @hidden */\nexport const UNSUPPORTED_OPERATION = 'UNSUPPORTED_OPERATION';\n\n// tslint:disable-next-line: variable-name\n/** @hidden */\nlet _permanentCensorErrors = false;\n// tslint:disable-next-line: variable-name\n/** @hidden */\nlet _censorErrors = false;\n\n// @TODO: Enum\n/** @hidden */\nexport function throwError(message: string, code: string | null | undefined, params: any): never {\n  if (_censorErrors) {\n    throw new Error('unknown error');\n  }\n\n  if (!code) {\n    code = UNKNOWN_ERROR;\n  }\n  if (!params) {\n    params = {};\n  }\n\n  const messageDetails: string[] = [];\n  Object.keys(params).forEach((key) => {\n    try {\n      messageDetails.push(key + '=' + JSON.stringify(params[key]));\n    } catch (error) {\n      messageDetails.push(key + '=' + JSON.stringify(params[key].toString()));\n    }\n  });\n  messageDetails.push('version=' + '#version');\n\n  const reason = message;\n  if (messageDetails.length) {\n    message += ' (' + messageDetails.join(', ') + ')';\n  }\n\n  // @TODO: Any??\n  const error: any = new Error(message);\n  error.reason = reason;\n  error.code = code;\n\n  Object.keys(params).forEach((key) => {\n    error[key] = params[key];\n  });\n\n  throw error;\n}\n\n/** @hidden */\nexport function checkNew(self: any, kind: any): void {\n  if (!(self instanceof kind)) {\n    throwError('missing new', MISSING_NEW, { name: kind.name });\n  }\n}\n\n/** @hidden */\nexport function checkArgumentCount(count: number, expectedCount: number, suffix?: string): void {\n  if (!suffix) {\n    suffix = '';\n  }\n  if (count < expectedCount) {\n    throwError('missing argument' + suffix, MISSING_ARGUMENT, {\n      count,\n      expectedCount,\n    });\n  }\n  if (count > expectedCount) {\n    throwError('too many arguments' + suffix, UNEXPECTED_ARGUMENT, {\n      count,\n      expectedCount,\n    });\n  }\n}\n\n/** @hidden */\nexport function setCensorship(censorship: boolean, permanent?: boolean): void {\n  if (_permanentCensorErrors) {\n    throwError('error censorship permanent', UNSUPPORTED_OPERATION, {\n      operation: 'setCensorship',\n    });\n  }\n\n  _censorErrors = !!censorship;\n  _permanentCensorErrors = !!permanent;\n}\n\n/** @hidden */\nexport function checkNormalize(): void {\n  try {\n    // Make sure all forms of normalization are supported\n    ['NFD', 'NFC', 'NFKD', 'NFKC'].forEach((form) => {\n      try {\n        'test'.normalize(form);\n      } catch (error) {\n        throw new Error('missing ' + form);\n      }\n    });\n\n    if (String.fromCharCode(0xe9).normalize('NFD') !== String.fromCharCode(0x65, 0x0301)) {\n      throw new Error('broken implementation');\n    }\n  } catch (error) {\n    throwError('platform missing String.prototype.normalize', UNSUPPORTED_OPERATION, {\n      operation: 'String.prototype.normalize',\n      form: error.message,\n    });\n  }\n}\n\n/** @hidden */\nconst LogLevels: { [name: string]: number } = {\n  debug: 1,\n  default: 2,\n  info: 2,\n  warn: 3,\n  error: 4,\n  off: 5,\n};\n/** @hidden */\nlet LogLevel = LogLevels.default;\n\n/** @hidden */\nexport function setLogLevel(logLevel: string): void {\n  const level = LogLevels[logLevel];\n  if (level == null) {\n    warn('invliad log level - ' + logLevel);\n    return;\n  }\n  LogLevel = level;\n}\n\n/** @hidden */\nfunction log(logLevel: string, args: [any?, ...any[]]): void {\n  if (LogLevel > LogLevels[logLevel]) {\n    return;\n  }\n  console.log.apply(console, args);\n}\n\n/** @hidden */\nexport function warn(...args: [any?, ...any[]]): void {\n  log('warn', args);\n}\n\n/** @hidden */\nexport function info(...args: [any?, ...any[]]): void {\n  log('info', args);\n}\n","/**\n * @packageDocumentation\n * @module avalanche-crypto\n * @hidden\n */\n\n// This file is ported from ether.js/src.ts/utils/bytes.ts\n// and done some fixes\n\nimport * as errors from './errors';\n\nexport type Arrayish = string | ArrayLike<number>;\n\nexport interface Hexable {\n  toHexString(): string;\n}\n\nexport interface Signature {\n  r: string;\n  s: string;\n\n  /* At least avax of the following MUST be specified; the other will be derived */\n  recoveryParam?: number;\n  v?: number;\n}\n\n///////////////////////////////\n\nexport function isHexable(value: any): value is Hexable {\n  return !!value.toHexString;\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n  if (typeof array === 'object' && typeof array.slice === 'function') {\n    return array;\n  }\n\n  // tslint:disable-next-line: only-arrow-functions\n  array.slice = function() {\n    const args = Array.prototype.slice.call(arguments);\n    return addSlice(new Uint8Array(Array.prototype.slice.apply(array, [args[0], args[1]])));\n  };\n\n  return array;\n}\n\nexport function isArrayish(value: any): value is Arrayish {\n  if (\n    !value ||\n    // tslint:disable-next-line: radix\n    parseInt(String(value.length)) !== value.length ||\n    typeof value === 'string'\n  ) {\n    return false;\n  }\n\n  // tslint:disable-next-line: prefer-for-of\n  for (let i = 0; i < value.length; i++) {\n    const v = value[i];\n    // tslint:disable-next-line: radix\n    if (v < 0 || v >= 256 || parseInt(String(v)) !== v) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport function arrayify(value: Arrayish | Hexable): Uint8Array | null {\n  if (value == null) {\n    errors.throwError('cannot convert null value to array', errors.INVALID_ARGUMENT, {\n      arg: 'value',\n      value,\n    });\n  }\n\n  if (isHexable(value)) {\n    value = value.toHexString();\n  }\n\n  if (typeof value === 'string') {\n    const match = value.match(/^(0x)?[0-9a-fA-F]*$/);\n\n    if (!match) {\n      errors.throwError('invalid hexidecimal string', errors.INVALID_ARGUMENT, {\n        arg: 'value',\n        value,\n      });\n    }\n\n    if (match !== null && match[1] !== '0x') {\n      errors.throwError('hex string must have 0x prefix', errors.INVALID_ARGUMENT, {\n        arg: 'value',\n        value,\n      });\n    }\n\n    value = value.substring(2);\n    if (value.length % 2) {\n      value = '0' + value;\n    }\n\n    const result = [];\n    for (let i = 0; i < value.length; i += 2) {\n      result.push(parseInt(value.substr(i, 2), 16));\n    }\n\n    return addSlice(new Uint8Array(result));\n  }\n\n  if (isArrayish(value)) {\n    return addSlice(new Uint8Array(value));\n  }\n\n  errors.throwError('invalid arrayify value', null, {\n    arg: 'value',\n    value,\n    type: typeof value,\n  });\n  return null;\n}\n\nexport function concat(objects: Arrayish[]): Uint8Array {\n  if (objects === null) {\n    throw new Error(`concat objects is null`);\n  }\n  const arrays = [];\n  let length = 0;\n  // tslint:disable-next-line: prefer-for-of\n  for (let i = 0; i < objects.length; i++) {\n    const object = arrayify(objects[i]);\n    if (object == null) {\n      throw new Error('arrayify failed');\n    }\n    arrays.push(object);\n    length += object.length;\n  }\n\n  const result = new Uint8Array(length);\n  let offset = 0;\n  // tslint:disable-next-line: prefer-for-of\n  for (let i = 0; i < arrays.length; i++) {\n    result.set(arrays[i], offset);\n    offset += arrays[i].length;\n  }\n\n  return addSlice(result);\n}\n\nexport function stripZeros(value: Arrayish): Uint8Array {\n  let result: Uint8Array | null = arrayify(value);\n\n  if (result === null) {\n    throw new Error('arrayify failed');\n  }\n\n  if (result.length === 0) {\n    return result;\n  }\n\n  // Find the first non-zero entry\n  let start = 0;\n  while (result[start] === 0) {\n    start++;\n  }\n\n  // If we started with zeros, strip them\n  if (start) {\n    result = result.slice(start);\n  }\n\n  return result;\n}\n\nexport function padZeros(value: Arrayish, length: number): Uint8Array {\n  const arrayifyValue = arrayify(value);\n  if (arrayifyValue === null) {\n    throw new Error('arrayify failed');\n  }\n  if (length < arrayifyValue.length) {\n    throw new Error('cannot pad');\n  }\n\n  const result = new Uint8Array(length);\n  result.set(arrayifyValue, length - arrayifyValue.length);\n  return addSlice(result);\n}\n\nexport function isHexString(value: any, length?: number): boolean {\n  if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n    return false;\n  }\n  if (length && value.length !== 2 + 2 * length) {\n    return false;\n  }\n  return true;\n}\n\nconst HexCharacters: string = '0123456789abcdef';\n\nexport function hexlify(value: Arrayish | Hexable | number): string {\n  if (isHexable(value)) {\n    return value.toHexString();\n  }\n\n  if (typeof value === 'number') {\n    if (value < 0) {\n      errors.throwError('cannot hexlify negative value', errors.INVALID_ARGUMENT, {\n        arg: 'value',\n        value,\n      });\n    }\n\n    // @TODO: Roll this into the above error as a numeric fault (overflow); next version, not backward compatible\n    // We can about (value == MAX_INT) to as well, since that may indicate we underflowed already\n    if (value >= 9007199254740991) {\n      errors.throwError('out-of-range', errors.NUMERIC_FAULT, {\n        operartion: 'hexlify',\n        fault: 'out-of-safe-range',\n      });\n    }\n\n    let hex = '';\n    while (value) {\n      hex = HexCharacters[value & 0x0f] + hex;\n      value = Math.floor(value / 16);\n    }\n\n    if (hex.length) {\n      if (hex.length % 2) {\n        hex = '0' + hex;\n      }\n      return '0x' + hex;\n    }\n\n    return '0x00';\n  }\n\n  if (typeof value === 'string') {\n    const match = value.match(/^(0x)?[0-9a-fA-F]*$/);\n\n    if (!match) {\n      errors.throwError('invalid hexidecimal string', errors.INVALID_ARGUMENT, {\n        arg: 'value',\n        value,\n      });\n    }\n\n    if (match !== null && match[1] !== '0x') {\n      errors.throwError('hex string must have 0x prefix', errors.INVALID_ARGUMENT, {\n        arg: 'value',\n        value,\n      });\n    }\n\n    if (value.length % 2) {\n      value = '0x0' + value.substring(2);\n    }\n    return value;\n  }\n\n  if (isArrayish(value)) {\n    const result = [];\n    // tslint:disable-next-line: prefer-for-of\n    for (let i = 0; i < value.length; i++) {\n      const v = value[i];\n      result.push(HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f]);\n    }\n    return '0x' + result.join('');\n  }\n\n  errors.throwError('invalid hexlify value', null, {\n    arg: 'value',\n    value,\n  });\n  return 'never';\n}\n\nexport function hexDataLength(data: string) {\n  if (!isHexString(data) || data.length % 2 !== 0) {\n    return null;\n  }\n  return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: string, offset: number, endOffset?: number): string {\n  if (!isHexString(data)) {\n    errors.throwError('invalid hex data', errors.INVALID_ARGUMENT, {\n      arg: 'value',\n      value: data,\n    });\n  }\n  if (data.length % 2 !== 0) {\n    errors.throwError('hex data length must be even', errors.INVALID_ARGUMENT, {\n      arg: 'value',\n      value: data,\n    });\n  }\n  offset = 2 + 2 * offset;\n\n  if (endOffset != null) {\n    return '0x' + data.substring(offset, 2 + 2 * endOffset);\n  }\n\n  return '0x' + data.substring(offset);\n}\n\nexport function hexStripZeros(value: string): string {\n  if (!isHexString(value)) {\n    errors.throwError('invalid hex string', errors.INVALID_ARGUMENT, {\n      arg: 'value',\n      value,\n    });\n  }\n  while (value.length > 3 && value.substring(0, 3) === '0x0') {\n    value = '0x' + value.substring(3);\n  }\n  return value;\n}\n\nexport function hexZeroPad(value: string, length: number): string {\n  if (!isHexString(value)) {\n    errors.throwError('invalid hex string', errors.INVALID_ARGUMENT, {\n      arg: 'value',\n      value,\n    });\n  }\n\n  while (value.length < 2 * length + 2) {\n    value = '0x0' + value.substring(2);\n  }\n  return value;\n}\n\nexport function bytesPadLeft(value: string, byteLength: number): string {\n  if (!isHexString(value)) {\n    errors.throwError('invalid hex string', errors.INVALID_ARGUMENT, {\n      arg: 'value',\n      value,\n    });\n  }\n\n  const striped = value.substring(2);\n  if (striped.length > byteLength * 2) {\n    throw new Error(`hex string length = ${striped.length} beyond byteLength=${byteLength}`);\n  }\n  const padLength = byteLength * 2 - striped.length;\n  const returnValue = '0x' + '0'.repeat(padLength) + striped;\n  return returnValue;\n}\nexport function bytesPadRight(value: string, byteLength: number): string {\n  if (!isHexString(value)) {\n    errors.throwError('invalid hex string', errors.INVALID_ARGUMENT, {\n      arg: 'value',\n      value,\n    });\n  }\n\n  const striped = value.substring(2);\n  if (striped.length > byteLength * 2) {\n    throw new Error(`hex string length = ${striped.length} beyond byteLength=${byteLength}`);\n  }\n  const padLength = byteLength * 2 - striped.length;\n  const returnValue = '0x' + striped + '0'.repeat(padLength);\n  return returnValue;\n}\n\nexport function isSignature(value: any): value is Signature {\n  return value && value.r != null && value.s != null;\n}\n\nexport function splitSignature(signature: Arrayish | Signature): Signature {\n  if (signature !== undefined) {\n    let v = 0;\n    let r = '0x';\n    let s = '0x';\n\n    if (isSignature(signature)) {\n      if (signature.v == null && signature.recoveryParam == null) {\n        errors.throwError(\n          'at least on of recoveryParam or v must be specified',\n          errors.INVALID_ARGUMENT,\n          { argument: 'signature', value: signature },\n        );\n      }\n      r = hexZeroPad(signature.r, 32);\n      s = hexZeroPad(signature.s, 32);\n\n      v = signature.v || 0;\n      if (typeof v === 'string') {\n        v = parseInt(v, 16);\n      }\n\n      let recoveryParam = signature.recoveryParam || 0;\n      if (recoveryParam == null && signature.v != null) {\n        recoveryParam = 1 - (v % 2);\n      }\n      v = 27 + recoveryParam;\n    } else {\n      const bytes: Uint8Array = arrayify(signature) || new Uint8Array();\n      if (bytes.length !== 65) {\n        throw new Error('invalid signature');\n      }\n      r = hexlify(bytes.slice(0, 32));\n      s = hexlify(bytes.slice(32, 64));\n\n      v = bytes[64];\n      if (v !== 27 && v !== 28) {\n        v = 27 + (v % 2);\n      }\n    }\n\n    return {\n      r,\n      s,\n      recoveryParam: v - 27,\n      v,\n    };\n  } else {\n    throw new Error('signature is not found');\n  }\n}\n\nexport function joinSignature(signature: Signature): string {\n  signature = splitSignature(signature);\n\n  return hexlify(concat([signature.r, signature.s, signature.recoveryParam ? '0x1c' : '0x1b']));\n}\n\n/**\n * hexToByteArray\n *\n * Convers a hex string to a Uint8Array\n *\n * @param {string} hex\n * @returns {Uint8Array}\n */\nexport const hexToByteArray = (hex: string): Uint8Array => {\n  const res = new Uint8Array(hex.length / 2);\n\n  for (let i = 0; i < hex.length; i += 2) {\n    res[i / 2] = parseInt(hex.substring(i, i + 2), 16);\n  }\n\n  return res;\n};\n\n/**\n * hexToIntArray\n *\n * @param {string} hex\n * @returns {number[]}\n */\nexport const hexToIntArray = (hex: string): number[] => {\n  if (!hex || !isHex(hex)) {\n    return [];\n  }\n\n  const res = [];\n\n  for (let i = 0; i < hex.length; i++) {\n    const c = hex.charCodeAt(i);\n    const hi = c >> 8;\n    const lo = c & 0xff;\n\n    hi ? res.push(hi, lo) : res.push(lo);\n  }\n\n  return res;\n};\n\n/**\n * isHex\n *\n * @param {string} str - string to be tested\n * @returns {boolean}\n */\nexport const isHex = (str: string): boolean => {\n  const plain = str.replace('0x', '');\n  return /[0-9a-f]*$/i.test(plain);\n};\n","/**\n * @packageDocumentation\n * @module avalanche-crypto\n * @ignore\n */\n\n// this file is ported from 'ether.js' and done some fixes\nimport * as sha3 from 'js-sha3';\n\nimport { arrayify, Arrayish } from './bytes';\n\nexport function keccak256(data: Arrayish): string {\n  const arrayified = arrayify(data);\n  if (arrayified) {\n    return '0x' + sha3.keccak_256(arrayified);\n  }\n  throw new Error('arrayify failed');\n}\n\n// export function sha3_256(data: Arrayish): string {\n//   const arrayified = arrayify(data);\n//   if (arrayified) {\n//     return '0x' + sha3.sha3_256(arrayified);\n//   }\n//   throw new Error('arrayify failed');\n// }\n","/**\n * @packageDocumentation\n * @module avalanche-crypto\n * @hidden\n */\n\nimport { isAddress } from 'avalanche-js-utils';\n\nimport { toChecksumAddress } from './keyTool';\n// This code is taken from https://github.com/sipa/bech32/tree/bdc264f84014c234e908d72026b7b780122be11f/ref/javascript\n// Copyright (c) 2017 Pieter Wuille\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nconst CHARSET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';\nconst GENERATOR = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\n\nconst polymod = (values: Buffer): number => {\n  let chk = 1;\n  // tslint:disable-next-line\n  for (let p = 0; p < values.length; ++p) {\n    const top = chk >> 25;\n    chk = ((chk & 0x1ffffff) << 5) ^ values[p];\n    for (let i = 0; i < 5; ++i) {\n      if ((top >> i) & 1) {\n        chk ^= GENERATOR[i];\n      }\n    }\n  }\n  return chk;\n};\n\nconst hrpExpand = (hrp: string): Buffer => {\n  const ret = [];\n  let p;\n  for (p = 0; p < hrp.length; ++p) {\n    ret.push(hrp.charCodeAt(p) >> 5);\n  }\n  ret.push(0);\n  for (p = 0; p < hrp.length; ++p) {\n    ret.push(hrp.charCodeAt(p) & 31);\n  }\n  return Buffer.from(ret);\n};\n\nfunction verifyChecksum(hrp: string, data: Buffer) {\n  return polymod(Buffer.concat([hrpExpand(hrp), data])) === 1;\n}\n\nfunction createChecksum(hrp: string, data: Buffer) {\n  const values = Buffer.concat([\n    Buffer.from(hrpExpand(hrp)),\n    data,\n    Buffer.from([0, 0, 0, 0, 0, 0]),\n  ]);\n  // var values = hrpExpand(hrp).concat(data).concat([0, 0, 0, 0, 0, 0]);\n  const mod = polymod(values) ^ 1;\n  const ret = [];\n  for (let p = 0; p < 6; ++p) {\n    ret.push((mod >> (5 * (5 - p))) & 31);\n  }\n  return Buffer.from(ret);\n}\n\nexport const bech32Encode = (hrp: string, data: Buffer) => {\n  const combined = Buffer.concat([data, createChecksum(hrp, data)]);\n  let ret = hrp + '1';\n  // tslint:disable-next-line\n  for (let p = 0; p < combined.length; ++p) {\n    ret += CHARSET.charAt(combined[p]);\n  }\n  return ret;\n};\n\nexport const bech32Decode = (bechString: string) => {\n  let p;\n  let hasLower = false;\n  let hasUpper = false;\n  for (p = 0; p < bechString.length; ++p) {\n    if (bechString.charCodeAt(p) < 33 || bechString.charCodeAt(p) > 126) {\n      return null;\n    }\n    if (bechString.charCodeAt(p) >= 97 && bechString.charCodeAt(p) <= 122) {\n      hasLower = true;\n    }\n    if (bechString.charCodeAt(p) >= 65 && bechString.charCodeAt(p) <= 90) {\n      hasUpper = true;\n    }\n  }\n  if (hasLower && hasUpper) {\n    return null;\n  }\n  bechString = bechString.toLowerCase();\n  const pos = bechString.lastIndexOf('1');\n  if (pos < 1 || pos + 7 > bechString.length || bechString.length > 90) {\n    return null;\n  }\n  const hrp = bechString.substring(0, pos);\n  const data = [];\n  for (p = pos + 1; p < bechString.length; ++p) {\n    const d = CHARSET.indexOf(bechString.charAt(p));\n    if (d === -1) {\n      return null;\n    }\n    data.push(d);\n  }\n\n  if (!verifyChecksum(hrp, Buffer.from(data))) {\n    return null;\n  }\n\n  return { hrp, data: Buffer.from(data.slice(0, data.length - 6)) };\n};\n\n// HRP is the human-readable part of Avalanche bech32 addresses\nexport const HRP = 'avax';\nexport const tHRP = 'tavax';\n\n/**\n * convertBits\n *\n * groups buffers of a certain width to buffers of the desired width.\n *\n * For example, converts byte buffers to buffers of maximum 5 bit numbers,\n * padding those numbers as necessary. Necessary for encoding Ethereum-style\n * addresses as bech32 avaxs.\n *\n * @param {Buffer} data\n * @param {number} fromWidth\n * @param {number} toWidth\n * @param {boolean} pad\n * @returns {Buffer|null}\n */\nexport const convertBits = (\n  data: Buffer,\n  fromWidth: number,\n  toWidth: number,\n  pad: boolean = true,\n) => {\n  let acc = 0;\n  let bits = 0;\n  const ret = [];\n  const maxv = (1 << toWidth) - 1;\n  // tslint:disable-next-line\n  for (let p = 0; p < data.length; ++p) {\n    const value = data[p];\n    if (value < 0 || value >> fromWidth !== 0) {\n      return null;\n    }\n    acc = (acc << fromWidth) | value;\n    bits += fromWidth;\n    while (bits >= toWidth) {\n      bits -= toWidth;\n      ret.push((acc >> bits) & maxv);\n    }\n  }\n\n  if (pad) {\n    if (bits > 0) {\n      ret.push((acc << (toWidth - bits)) & maxv);\n    }\n  } else if (bits >= fromWidth || (acc << (toWidth - bits)) & maxv) {\n    return null;\n  }\n\n  return Buffer.from(ret);\n};\n\n/**\n * toBech32Address\n *\n * bech32Encodes a canonical 20-byte Ethereum-style address as a bech32 Avalanche\n * address.\n *\n * The expected format is avax1<address><checksum> where address and checksum\n * are the result of bech32 encoding a Buffer containing the address bytes.\n *\n * @param {string} 20 byte canonical address\n * @returns {string} 38 char bech32 bech32Encoded Avalanche address\n */\nexport const toBech32 = (address: string, useHRP: string = HRP): string => {\n  if (!isAddress(address)) {\n    throw new Error('Invalid address format.');\n  }\n\n  const addrBz = convertBits(Buffer.from(address.replace('0x', ''), 'hex'), 8, 5);\n\n  if (addrBz === null) {\n    throw new Error('Could not convert byte Buffer to 5-bit Buffer');\n  }\n\n  return bech32Encode(useHRP, addrBz);\n};\n\n/**\n * fromBech32Address\n *\n * @param {string} address - a valid Avalanche bech32 address\n * @returns {string} a canonical 20-byte Ethereum-style address\n */\nexport const fromBech32 = (address: string, useHRP: string = HRP): string => {\n  const res = bech32Decode(address);\n\n  if (res === null) {\n    throw new Error('Invalid bech32 address');\n  }\n\n  const { hrp, data } = res;\n\n  if (hrp !== useHRP) {\n    throw new Error(`Expected hrp to be ${useHRP} but got ${hrp}`);\n  }\n\n  const buf = convertBits(data, 5, 8, false);\n\n  if (buf === null) {\n    throw new Error('Could not convert buffer to bytes');\n  }\n\n  return toChecksumAddress('0x' + buf.toString('hex'));\n};\n","/**\n * @packageDocumentation\n * @module avalanche-crypto\n * @hidden\n */\n\n// this file is ported from https://github.com/ethers-io/ethers.js/blob/master/src.ts/utils/rlp.ts\n// and done some fixes\nimport { arrayify, hexlify, Arrayish } from './bytes';\n\nfunction arrayifyInteger(value: number): number[] {\n  const result = [];\n  while (value) {\n    result.unshift(value & 0xff);\n    value >>= 8;\n  }\n  return result;\n}\n\nfunction unarrayifyInteger(data: Uint8Array, offset: number, length: number): number {\n  let result = 0;\n  for (let i = 0; i < length; i++) {\n    result = result * 256 + data[offset + i];\n  }\n  return result;\n}\n\nfunction _encode(object: any[] | string): number[] {\n  if (Array.isArray(object)) {\n    let payload: number[] = [];\n    object.forEach((child) => {\n      payload = payload.concat(_encode(child));\n    });\n\n    if (payload.length <= 55) {\n      payload.unshift(0xc0 + payload.length);\n      return payload;\n    }\n\n    // tslint:disable-next-line: no-shadowed-variable\n    const length = arrayifyInteger(payload.length);\n    length.unshift(0xf7 + length.length);\n\n    return length.concat(payload);\n  }\n\n  const data: number[] = Array.prototype.slice.call(arrayify(object));\n\n  if (data.length === 1 && data[0] <= 0x7f) {\n    return data;\n  } else if (data.length <= 55) {\n    data.unshift(0x80 + data.length);\n    return data;\n  }\n\n  const length = arrayifyInteger(data.length);\n  length.unshift(0xb7 + length.length);\n\n  return length.concat(data);\n}\n\nexport function encode(object: any): string {\n  return hexlify(_encode(object));\n}\n\ninterface Decoded {\n  result: any;\n  consumed: number;\n}\n\nfunction _decodeChildren(\n  data: Uint8Array,\n  offset: number,\n  childOffset: number,\n  length: number,\n): Decoded {\n  const result = [];\n\n  while (childOffset < offset + 1 + length) {\n    const decoded = _decode(data, childOffset);\n\n    result.push(decoded.result);\n\n    childOffset += decoded.consumed;\n    if (childOffset > offset + 1 + length) {\n      throw new Error('invalid rlp');\n    }\n  }\n\n  return { consumed: 1 + length, result };\n}\n\n// returns { consumed: number, result: Object }\nfunction _decode(data: Uint8Array, offset: number): { consumed: number; result: any } {\n  if (data.length === 0) {\n    throw new Error('invalid rlp data');\n  }\n\n  // Array with extra length prefix\n  if (data[offset] >= 0xf8) {\n    const lengthLength = data[offset] - 0xf7;\n    if (offset + 1 + lengthLength > data.length) {\n      throw new Error('too short');\n    }\n\n    const length = unarrayifyInteger(data, offset + 1, lengthLength);\n    if (offset + 1 + lengthLength + length > data.length) {\n      throw new Error('to short');\n    }\n\n    return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);\n  } else if (data[offset] >= 0xc0) {\n    const length = data[offset] - 0xc0;\n    if (offset + 1 + length > data.length) {\n      throw new Error('invalid rlp data');\n    }\n\n    return _decodeChildren(data, offset, offset + 1, length);\n  } else if (data[offset] >= 0xb8) {\n    const lengthLength = data[offset] - 0xb7;\n    if (offset + 1 + lengthLength > data.length) {\n      throw new Error('invalid rlp data');\n    }\n\n    const length = unarrayifyInteger(data, offset + 1, lengthLength);\n    if (offset + 1 + lengthLength + length > data.length) {\n      throw new Error('invalid rlp data');\n    }\n\n    const result = hexlify(\n      data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length),\n    );\n    return { consumed: 1 + lengthLength + length, result };\n  } else if (data[offset] >= 0x80) {\n    const length = data[offset] - 0x80;\n    if (offset + 1 + length > data.length) {\n      throw new Error('invlaid rlp data');\n    }\n\n    const result = hexlify(data.slice(offset + 1, offset + 1 + length));\n    return { consumed: 1 + length, result };\n  }\n  return { consumed: 1, result: hexlify(data[offset]) };\n}\n\nexport function decode(data: Arrayish): any {\n  const bytes = arrayify(data) || new Uint8Array();\n  const decoded = _decode(bytes, 0);\n  if (decoded.consumed !== bytes.length) {\n    throw new Error('invalid rlp data');\n  }\n  return decoded.result;\n}\n","/**\n * @packageDocumentation\n * @module avalanche-crypto\n */\n\nimport elliptic from 'elliptic';\nimport * as bytes from './bytes';\nimport * as errors from './errors';\n\nimport { keccak256 } from './keccak256';\nimport { randomBytes } from './random';\nimport { isPrivateKey, strip0x, isAddress, isBech32Address } from 'avalanche-js-utils';\nimport { fromBech32 } from './bech32';\nimport { encode } from './rlp';\n\nconst secp256k1 = elliptic.ec('secp256k1');\n\n/**\n * @function generatePrivateKey\n * @description generatePrivate key using `eth-lib` settings\n * @return {string}\n */\nexport const generatePrivateKey = (): string => {\n  const entropy: string = '0x' + randomBytes(16);\n\n  const innerHex: string = keccak256(\n    bytes.concat(['0x' + randomBytes(32), entropy || '0x' + randomBytes(32)]),\n  );\n  const middleHex: Uint8Array = bytes.concat([\n    bytes.concat(['0x' + randomBytes(32), innerHex]),\n    '0x' + randomBytes(32),\n  ]);\n  const outerHex: string = keccak256(middleHex);\n  return outerHex;\n};\n\n/**\n * @function getPubkeyFromPrivateKey\n * @param  {string} privateKey - private key String\n * @return {string}\n */\nexport const getPubkeyFromPrivateKey = (privateKey: string): string => {\n  return '0x' + getPublic(privateKey, true);\n};\n\n/**\n * @function getAddressFromPrivateKey\n * @param  {string} privateKey - private key string\n * @return {string} address with `length = 40`\n */\nexport const getAddressFromPrivateKey = (privateKey: string): string => {\n  const publicHash = '0x' + getPublic(privateKey).slice(2);\n  const publicKey = keccak256(publicHash);\n  const address = '0x' + publicKey.slice(-40);\n  return address;\n};\n\nexport const getPublic = (privateKey: string, compress?: boolean): string => {\n  if (!isPrivateKey(privateKey) || !validatePrivateKey(privateKey)) {\n    throw new Error(`${privateKey} is not PrivateKey`);\n  }\n  const ecKey = secp256k1.keyFromPrivate(strip0x(privateKey), 'hex');\n\n  return ecKey.getPublic(compress || false, 'hex');\n};\n\n/**\n * @function getAddressFromPublicKey\n * @param  {string} publicKey - public key string\n * @return {string} address with `length = 40`\n */\nexport const getAddressFromPublicKey = (publicKey: string): string => {\n  const ecKey = secp256k1.keyFromPublic(publicKey.slice(2), 'hex');\n  const publicHash = ecKey.getPublic(false, 'hex');\n  const address = '0x' + keccak256('0x' + publicHash.slice(2)).slice(-40);\n  return address;\n};\n\n/**\n * @function toChecksumAddress\n * @param  {string} address - raw address\n * @return {string} checksumed address\n */\nexport const toChecksumAddress = (address: string): string => {\n  if (typeof address === 'string' && isBech32Address(address)) {\n    address = fromBech32(address);\n  }\n  if (typeof address !== 'string' || !address.match(/^0x[0-9A-Fa-f]{40}$/)) {\n    errors.throwError('invalid address', errors.INVALID_ARGUMENT, {\n      arg: 'address',\n      value: address,\n    });\n  }\n\n  address = address.toLowerCase();\n\n  const chars = address.substring(2).split('');\n\n  let hashed = new Uint8Array(40);\n  for (let i = 0; i < 40; i++) {\n    hashed[i] = chars[i].charCodeAt(0);\n  }\n  hashed = bytes.arrayify(keccak256(hashed)) || hashed;\n\n  for (let i = 0; i < 40; i += 2) {\n    if (hashed[i >> 1] >> 4 >= 8) {\n      chars[i] = chars[i].toUpperCase();\n    }\n    if ((hashed[i >> 1] & 0x0f) >= 8) {\n      chars[i + 1] = chars[i + 1].toUpperCase();\n    }\n  }\n\n  return '0x' + chars.join('');\n};\n\nexport const sign = (digest: bytes.Arrayish | string, privateKey: string): bytes.Signature => {\n  if (!isPrivateKey(privateKey)) {\n    throw new Error(`${privateKey} is not PrivateKey`);\n  }\n\n  const keyPair = secp256k1.keyFromPrivate(strip0x(privateKey), 'hex');\n  const signature = keyPair.sign(bytes.arrayify(digest), { canonical: true });\n  const publicKey = '0x' + keyPair.getPublic(true, 'hex');\n  const result = {\n    recoveryParam: signature.recoveryParam,\n    r: bytes.hexZeroPad('0x' + signature.r.toString(16), 32),\n    s: bytes.hexZeroPad('0x' + signature.s.toString(16), 32),\n    v: 27 + signature.recoveryParam,\n  };\n\n  if (verifySignature(digest, result, publicKey)) {\n    return result;\n  } else {\n    throw new Error('signing process failed');\n  }\n};\n\nexport function getContractAddress(from: string, nonce: number): string {\n  if (!from) {\n    throw new Error('missing from address');\n  }\n\n  const addr = keccak256(encode([from, bytes.stripZeros(bytes.hexlify(nonce))]));\n  return '0x' + addr.substring(26);\n}\n\nexport function verifySignature(\n  digest: bytes.Arrayish,\n  signature: bytes.Signature,\n  publicKey: string,\n): boolean {\n  return recoverPublicKey(digest, signature) === publicKey;\n}\n\nexport function recoverPublicKey(\n  digest: bytes.Arrayish | string,\n  signature: bytes.Signature | string,\n): string {\n  const sig = bytes.splitSignature(signature);\n  const rs = { r: bytes.arrayify(sig.r), s: bytes.arrayify(sig.s) };\n\n  ////\n  const recovered = secp256k1.recoverPubKey(bytes.arrayify(digest), rs, sig.recoveryParam);\n\n  const key = recovered.encode('hex', false);\n  const ecKey = secp256k1.keyFromPublic(key, 'hex');\n  const publicKey = '0x' + ecKey.getPublic(true, 'hex');\n\n  ///\n\n  return publicKey;\n}\n\nexport function recoverAddress(\n  digest: bytes.Arrayish | string,\n  signature: bytes.Signature | string,\n): string {\n  return getAddressFromPublicKey(\n    recoverPublicKey(bytes.arrayify(digest) || new Uint8Array(), signature),\n  );\n}\n\n/**\n * isValidChecksumAddress\n *\n * takes hex-encoded string and returns boolean if address is checksumed\n *\n * @param {string} address\n * @returns {boolean}\n */\nexport const isValidChecksumAddress = (address: string): boolean => {\n  return isAddress(address.replace('0x', '')) && toChecksumAddress(address) === address;\n};\n\nexport const validatePrivateKey = (privateKey: string): boolean => {\n  const ecKey = secp256k1.keyFromPrivate(strip0x(privateKey), 'hex');\n  const { result } = ecKey.validate();\n  return result;\n};\n","/**\n * @packageDocumentation\n * @module avalanche-crypto\n */\n\nimport aes from 'aes-js';\n// import scrypt from 'scrypt.js';\nimport scrypt from 'scrypt-shim';\nimport { pbkdf2Sync } from 'pbkdf2';\nimport uuid from 'uuid';\nimport { isPrivateKey } from 'avalanche-js-utils';\nimport { randomBytes } from './random';\nimport { getAddressFromPrivateKey } from './keyTool';\nimport { concat, hexToIntArray } from './bytes';\nimport { keccak256 } from './keccak256';\nimport { KDF, KDFParams, EncryptOptions, PBKDF2Params, ScryptParams, Keystore } from './types';\n\n/** @hidden */\nconst DEFAULT_ALGORITHM = 'aes-128-ctr';\n\n/**\n * getDerivedKey\n *\n * NOTE: only scrypt and pbkdf2 are supported.\n *\n * @param {Buffer} key - the passphrase\n * @param {KDF} kdf - the key derivation function to be used\n * @param {KDFParams} params - params for the kdf\n *\n * @returns {Promise<Buffer>}\n */\nasync function getDerivedKey(key: Buffer, kdf: KDF, params: KDFParams): Promise<Buffer> {\n  const salt = Buffer.from(params.salt, 'hex');\n\n  if (kdf === 'pbkdf2') {\n    const { c, dklen } = params as PBKDF2Params;\n    return pbkdf2Sync(key, salt, c, dklen, 'sha256');\n  }\n\n  if (kdf === 'scrypt') {\n    const { n, r, p, dklen } = params as ScryptParams;\n    return scrypt(key, salt, n, r, p, dklen);\n  }\n\n  throw new Error('Only pbkdf2 and scrypt are supported');\n}\n\n/**\n * This method will map the current Account object to V3Keystore object.\n *\n * @method encrypt\n *\n * @param {string} privateKey\n * @param {string} password\n * @param {object} options\n *\n * @return {{version, id, address, crypto}}\n */\nexport const encrypt = async (\n  privateKey: string,\n  password: string,\n  options?: EncryptOptions,\n): Promise<string> => {\n  if (!isPrivateKey(privateKey)) {\n    throw new Error('privateKey is not correct');\n  }\n  if (typeof password !== 'string') {\n    throw new Error('password is not found');\n  }\n  const address = getAddressFromPrivateKey(privateKey);\n\n  const salt = randomBytes(32);\n  const iv = Buffer.from(randomBytes(16), 'hex');\n  const kdf = options !== undefined ? (options.kdf ? options.kdf : 'scrypt') : 'scrypt';\n  const level = options !== undefined ? (options.level ? options.level : 8192) : 8192;\n\n  const uuidRandom = options !== undefined ? options.uuid : undefined;\n\n  const n = kdf === 'pbkdf2' ? 262144 : level;\n  const kdfparams = {\n    salt,\n    n,\n    r: 8,\n    p: 1,\n    dklen: 32,\n  };\n\n  const derivedKey = await getDerivedKey(Buffer.from(password), kdf, kdfparams);\n  const cipher = new aes.ModeOfOperation.ctr(derivedKey.slice(0, 16), new aes.Counter(iv));\n\n  if (!cipher) {\n    throw new Error('Unsupported cipher');\n  }\n\n  const ciphertext = Buffer.from(cipher.encrypt(Buffer.from(privateKey.replace('0x', ''), 'hex')));\n\n  const mac = keccak256(concat([derivedKey.slice(16, 32), ciphertext]));\n\n  return JSON.stringify({\n    version: 3,\n    id: uuid.v4({ random: uuidRandom || hexToIntArray(randomBytes(16)) }),\n    address: address.toLowerCase().replace('0x', ''),\n    crypto: {\n      ciphertext: ciphertext.toString('hex'),\n      cipherparams: {\n        iv: iv.toString('hex'),\n      },\n      cipher: DEFAULT_ALGORITHM,\n      kdf,\n      kdfparams,\n      mac: mac.replace('0x', ''),\n    },\n  });\n};\n\n/**\n * @function decrypt\n * @param  {Keystore} keystore - Keystore file\n * @param  {string} password - password string\n * @return {string} privateKey\n */\nexport const decrypt = async (keystore: Keystore, password: string): Promise<string> => {\n  const ciphertext = Buffer.from(keystore.crypto.ciphertext, 'hex');\n  const iv = Buffer.from(keystore.crypto.cipherparams.iv, 'hex');\n  const { kdfparams } = keystore.crypto;\n\n  const derivedKey = await getDerivedKey(Buffer.from(password), keystore.crypto.kdf, kdfparams);\n\n  const mac = keccak256(concat([derivedKey.slice(16, 32), ciphertext])).replace('0x', '');\n\n  if (mac.toUpperCase() !== keystore.crypto.mac.toUpperCase()) {\n    return Promise.reject(new Error('Failed to decrypt.'));\n  }\n\n  const CTR = aes.ModeOfOperation.ctr;\n\n  const cipher = new CTR(derivedKey.slice(0, 16), new aes.Counter(iv));\n\n  const decrypted = '0x' + Buffer.from(cipher.decrypt(ciphertext)).toString('hex');\n  return decrypted;\n};\n\n/**\n * encrypt Phrase\n */\nexport const encryptPhrase = async (\n  phrase: string,\n  password: string,\n  options?: EncryptOptions,\n): Promise<string> => {\n  if (typeof password !== 'string') {\n    throw new Error('password is not found');\n  }\n  const salt = randomBytes(32);\n  const iv = Buffer.from(randomBytes(16), 'hex');\n  const kdf = options !== undefined ? (options.kdf ? options.kdf : 'scrypt') : 'scrypt';\n  const level = options !== undefined ? (options.level ? options.level : 8192) : 8192;\n\n  const uuidRandom = options !== undefined ? options.uuid : undefined;\n\n  const n = kdf === 'pbkdf2' ? 262144 : level;\n  const kdfparams = {\n    salt,\n    n,\n    r: 8,\n    p: 1,\n    dklen: 32,\n  };\n  const derivedKey = await getDerivedKey(Buffer.from(password), kdf, kdfparams);\n  const cipher = new aes.ModeOfOperation.ctr(derivedKey.slice(0, 16), new aes.Counter(iv));\n\n  if (!cipher) {\n    throw new Error('Unsupported cipher');\n  }\n\n  const ciphertext = Buffer.from(cipher.encrypt(Buffer.from(phrase)));\n\n  const mac = keccak256(concat([derivedKey.slice(16, 32), ciphertext]));\n  return JSON.stringify({\n    version: 3,\n    id: uuid.v4({ random: uuidRandom || hexToIntArray(randomBytes(16)) }),\n    crypto: {\n      ciphertext: ciphertext.toString('hex'),\n      cipherparams: {\n        iv: iv.toString('hex'),\n      },\n      cipher: DEFAULT_ALGORITHM,\n      kdf,\n      kdfparams,\n      mac: mac.replace('0x', ''),\n    },\n  });\n};\n\n/**\n * decrypt phrase\n */\nexport const decryptPhrase = async (keystore: Keystore, password: string): Promise<string> => {\n  const result = await decrypt(keystore, password);\n  return Buffer.from(result.replace('0x', ''), 'hex').toString();\n};\n","/**\n * @packageDocumentation\n * @module avalanche-crypto\n */\n\nimport { isAddress, isBech32Address, isBech32TestNetAddress } from 'avalanche-js-utils';\n\nimport { toChecksumAddress } from './keyTool';\nimport { fromBech32, toBech32, HRP, tHRP } from './bech32';\n\n/**\n * ### How to use it?\n *\n * ```\n * // Step 1: import the class\n * const { AvalancheAddress } = require('avalanche-js-crypto');\n *\n * // Step 2: call functions\n * const addr = 'avax103q7qe5t2505lypvltkqtddaef5tzfxwsse4z7'\n * const res = AvalancheAddress.isValidBech32(addr);\n * console.log(res);\n * ```\n */\nexport class AvalancheAddress {\n  /**\n   * @example\n   * ```\n   * const addr = 'avax103q7qe5t2505lypvltkqtddaef5tzfxwsse4z7'\n   * const res = AvalancheAddress.isValidBech32(addr);\n   * console.log(res);\n   * ```\n   */\n  static isValidBasic(str: string) {\n    const toTest = new AvalancheAddress(str);\n    return toTest.raw === toTest.basic;\n  }\n\n  /**\n   * @example\n   * ```\n   * const addr = 'avax103q7qe5t2505lypvltkqtddaef5tzfxwsse4z7'\n   * const res = AvalancheAddress.isValidChecksum(addr);\n   * console.log(res);\n   * ```\n   */\n  static isValidChecksum(str: string) {\n    const toTest = new AvalancheAddress(str);\n    return toTest.raw === toTest.checksum;\n  }\n\n  /**\n   * @example\n   * ```\n   * const addr = 'avax103q7qe5t2505lypvltkqtddaef5tzfxwsse4z7'\n   * const res = AvalancheAddress.isValidBech32(addr);\n   * console.log(res);\n   * ```\n   */\n  static isValidBech32(str: string) {\n    const toTest = new AvalancheAddress(str);\n    return toTest.raw === toTest.bech32;\n  }\n\n  /**\n   * @example\n   * ```\n   * const addr = 'avax103q7qe5t2505lypvltkqtddaef5tzfxwsse4z7'\n   * const res = AvalancheAddress.isValidBech32TestNet(addr);\n   * console.log(res);\n   * ```\n   */\n  static isValidBech32TestNet(str: string) {\n    const toTest = new AvalancheAddress(str);\n    return toTest.raw === toTest.bech32TestNet;\n  }\n\n  raw: string;\n  basic: string;\n\n  /**\n   * get basicHex of the address\n   *\n   * @example\n   * ```\n   * const addr = 'avax103q7qe5t2505lypvltkqtddaef5tzfxwsse4z7'\n   * const instance = new AvalancheAddress(addr);\n   * console.log(instance.basicHex);\n   * ```\n   */\n  get basicHex() {\n    return `0x${this.basic}`;\n  }\n\n  /**\n   * @example\n   * ```\n   * const addr = 'avax103q7qe5t2505lypvltkqtddaef5tzfxwsse4z7'\n   * const instance = new AvalancheAddress(addr);\n   * console.log(instance.checksum);\n   * ```\n   */\n  get checksum() {\n    return toChecksumAddress(`0x${this.basic}`);\n  }\n\n  /**\n   * @example\n   * ```\n   * const addr = 'avax103q7qe5t2505lypvltkqtddaef5tzfxwsse4z7'\n   * const instance = new AvalancheAddress(addr);\n   * console.log(instance.bech32);\n   * ```\n   */\n  get bech32() {\n    return toBech32(this.basic, HRP);\n  }\n\n  /**\n   * @example\n   * ```\n   * const addr = 'avax103q7qe5t2505lypvltkqtddaef5tzfxwsse4z7'\n   * const instance = new AvalancheAddress(addr);\n   * console.log(instance.bech32TestNet);\n   * ```\n   */\n  get bech32TestNet() {\n    return toBech32(this.basic, tHRP);\n  }\n\n  constructor(raw: string) {\n    this.raw = raw;\n    this.basic = this.getBasic(this.raw);\n  }\n\n  /**\n   * Check whether the address has an valid address format\n   *\n   * @param addr string, the address\n   *\n   * @example\n   * ```\n   * const addr = 'avax103q7qe5t2505lypvltkqtddaef5tzfxwsse4z7'\n   * const instance = new AvalancheAddress(addr);\n   * const res = instance.getBasic(addr);\n   * console.log(res)\n   * ```\n   */\n  private getBasic(addr: string) {\n    const basicBool = isAddress(addr);\n    const bech32Bool = isBech32Address(addr);\n    const bech32TestNetBool = isBech32TestNetAddress(addr);\n\n    if (basicBool) {\n      return addr.replace('0x', '').toLowerCase();\n    }\n\n    if (bech32Bool) {\n      const fromB32 = fromBech32(addr, HRP);\n      return fromB32.replace('0x', '').toLowerCase();\n    }\n\n    if (bech32TestNetBool) {\n      const fromB32TestNet = fromBech32(addr, tHRP);\n      return fromB32TestNet.replace('0x', '').toLowerCase();\n    }\n\n    throw new Error(`\"${addr}\" is an invalid address format`);\n  }\n}\n\n/**\n * Using this function to get Avalanche format address\n *\n * @param address\n *\n * @example\n * ```javascript\n * const { Avalanche } = require('avalanche-js-core');\n * const { ChainID, ChainType } = require('avalanche-js-utils');\n * const { randomBytes } = require('avalanche-js-crypto')\n *\n * const hmy = new Avalanche(\n *   'http://localhost:9500',\n *   {\n *   chainType: ChainType.Avalanche,\n *   chainId: ChainID.HmyLocal,\n *   },\n * );\n *\n * const bytes = randomBytes(20);\n * const hAddress = hmy.crypto.getAddress(bytes);\n * console.log(hAddress)\n * ```\n */\nexport function getAddress(address: string) {\n  try {\n    return new AvalancheAddress(address);\n  } catch (error) {\n    throw error;\n  }\n}\n"],"names":["randomBytes","bytes","randBz","window","crypto","getRandomValues","Uint8Array","require","Error","randStr","i","toString","slice","_permanentCensorErrors","_censorErrors","throwError","message","code","params","messageDetails","Object","keys","forEach","key","push","JSON","stringify","error","reason","length","join","LogLevels","debug","info","warn","off","LogLevel","log","logLevel","args","console","apply","isHexable","value","toHexString","addSlice","array","Array","prototype","call","arguments","isArrayish","parseInt","String","v","arrayify","errors","arg","match","substring","result","substr","type","concat","objects","arrays","object","offset","set","stripZeros","start","isHexString","hexlify","operartion","fault","hex","Math","floor","hexZeroPad","isSignature","r","s","splitSignature","signature","undefined","recoveryParam","argument","hexToIntArray","isHex","res","c","charCodeAt","hi","lo","str","plain","replace","test","keccak256","data","arrayified","sha3","CHARSET","GENERATOR","polymod","values","chk","p","top","hrpExpand","hrp","ret","Buffer","from","createChecksum","mod","bech32Encode","combined","charAt","bech32Decode","bechString","hasLower","hasUpper","pos","toLowerCase","lastIndexOf","d","indexOf","verifyChecksum","HRP","convertBits","fromWidth","toWidth","pad","acc","bits","maxv","toBech32","address","useHRP","isAddress","addrBz","fromBech32","buf","toChecksumAddress","arrayifyInteger","unshift","unarrayifyInteger","encode","_encode","isArray","payload","child","_decodeChildren","childOffset","decoded","_decode","consumed","lengthLength","secp256k1","elliptic","ec","getAddressFromPrivateKey","privateKey","getPublic","compress","isPrivateKey","validatePrivateKey","keyFromPrivate","strip0x","getAddressFromPublicKey","publicKey","keyFromPublic","isBech32Address","chars","split","hashed","toUpperCase","verifySignature","digest","recoverPublicKey","sig","rs","recoverPubKey","validate","getDerivedKey","kdf","salt","pbkdf2Sync","dklen","scrypt","n","encrypt","password","options","iv","level","uuidRandom","uuid","kdfparams","cipher","aes","ModeOfOperation","ctr","derivedKey","Counter","ciphertext","mac","version","id","v4","random","cipherparams","decrypt","keystore","Promise","reject","CTR","decrypted","encryptPhrase","phrase","decryptPhrase","AvalancheAddress","raw","basic","this","getBasic","isValidBasic","toTest","isValidChecksum","checksum","isValidBech32","bech32","isValidBech32TestNet","bech32TestNet","addr","basicBool","bech32Bool","bech32TestNetBool","isBech32TestNetAddress","byteLength","striped","repeat","count","expectedCount","suffix","self","kind","name","form","normalize","fromCharCode","operation","entropy","innerHex","nonce","endOffset","arrayifyValue","censorship","permanent","keyPair","sign","canonical"],"mappings":"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"}